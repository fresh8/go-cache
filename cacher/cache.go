//go:generate moq -out ./cacher_mock.go . Cacher
//go:generate goimports -w ./cacher_mock.go

package cacher

import (
	"math/rand"
	"time"

	"github.com/fresh8/go-cache/engine/common"
	"github.com/fresh8/go-cache/joque"
	"github.com/fresh8/go-cache/metrics"
	"github.com/prometheus/client_golang/prometheus"
)

type cacher struct {
	engine         common.Engine
	jobQueue       chan joque.Job
	retryLockCheck int
	waitTime       time.Duration
}

// Cacher defines the interface for a caching system so it can be customised.
type Cacher interface {
	Get(string, time.Time, func() ([]byte, error)) func() ([]byte, error)
	Expire(string) error
}

// NewCacher creates a new generic cacher with the given engine.
func NewCacher(engine common.Engine, maxQueueSize int, maxWorkers int, retryLockCheck int, waitTime time.Duration) Cacher {
	return cacher{
		engine:         engine,
		jobQueue:       joque.Setup(maxQueueSize, maxWorkers),
		retryLockCheck: retryLockCheck,
		waitTime:       waitTime,
	}
}

func (c cacher) get(key string, expires time.Time, regenerate func() ([]byte, error)) (data []byte, err error) {
	if c.engine.Exists(key) {
		// Capture how many times a cache key is found
		metrics.GoCacheKeyHits.Inc()

		data, err = c.engine.Get(key)

		// Return, something went wrong
		if err != nil {
			// Capture how many times a engine request fails
			metrics.GoCacheEngineFailed.
				With(prometheus.Labels{"type": "get"}).
				Inc()
			return
		}

		// Return, data is fresh enough
		if !c.engine.IsExpired(key) {
			return
		}

		// Return, as data is being regenerated by another process
		if c.engine.IsLocked(key) {
			metrics.GoCacheEngineLocked.
				With(prometheus.Labels{"location": "has_cached"}).
				Inc()
		}

		// We should only be queueing cache regeneration when expiry is
		// certain fraction e.g. < 85% elapsed time.

		metrics.GoCacheQueuedFunctions.Inc()
		c.jobQueue <- func() {
			// Metric to add something being added to the queue

			// TODO handle errors within this function
			c.engine.Lock(key)
			defer c.engine.Unlock(key)

			regeneratedData, regenerateError := regenerate()
			if regenerateError == nil {
				c.engine.Put(key, regeneratedData, expires)
			}
		}
		return
	}

	// Capture how many times a cache key is not found
	metrics.GoCacheKeyMiss.Inc()

	// Return, as data is being regenerated by another process
	if c.engine.IsLocked(key) {
		metrics.GoCacheEngineLocked.
			With(prometheus.Labels{"location": "has_no_cached"}).
			Inc()
		// re-try calling c.engine.IsLocked(key) 5 times after a delay
		errMsg := RetryCheck(c.retryLockCheck, c.waitTime, func() error {
			if c.engine.IsLocked(key) {
				return common.ErrEngineLocked
			}
			return nil
		})
		if errMsg != nil {
			return nil, common.ErrEngineLocked
		}
		data, err = c.engine.Get(key)
		return

	}

	// Lock on initial generation so that things
	c.engine.Lock(key)
	defer c.engine.Unlock(key)

	// If the key doesn't exist, generate it now and return
	data, err = regenerate()
	if err != nil {
		metrics.GoCacheRegenerateFailure.
			With(prometheus.Labels{"location": "not_locked"}).
			Inc()
		return
	}

	err = c.engine.Put(key, data, expires)
	if err != nil {
		metrics.GoCacheEngineFailed.
			With(prometheus.Labels{"type": "put"}).
			Inc()
	}

	return
}

func (c cacher) Get(key string, expires time.Time, regenerate func() ([]byte, error)) func() ([]byte, error) {
	var data []byte
	var err error

	ch := make(chan struct{}, 1)
	go func() {
		defer close(ch)
		data, err = c.get(key, expires, regenerate)
	}()

	return func() ([]byte, error) {
		<-ch
		return data, err
	}
}

// Expire the given key within the cache engine
func (c cacher) Expire(key string) error {
	return c.engine.Expire(key)
}

// RetryCheck - function will attempt to check the engine lock after a wait time.
// as the  check returns boolean this will retry until a false is returned.
func RetryCheck(retries int, waitTime time.Duration, retryFunction func() error) error {
	err := retryFunction()
	if err != nil {
		// Decrement retries counter
		retries = retries - 1
		// If we still have more retries continue
		if retries > 0 {
			// Add a small amount of random time to the wait time so the gap between
			// each retry is slightly larger amount of time
			waitTime = waitTime + time.Duration(rand.Int63n(int64(waitTime)))/2
			// Wait a fixed amount of time before re-trying
			time.Sleep(waitTime)
			return RetryCheck(retries, waitTime, retryFunction)
		}
		return err
	}
	return nil
}
